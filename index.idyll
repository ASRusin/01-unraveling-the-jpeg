[meta title:"Unraveling The JPEG" description:"JPEG images are everywhere, yet how they work remains a mystery to most. The secret is getting rid of almost unnoticeable details to get the smallest filesize - but what does that look like? Let's see what our eyes can't see." /]

[Nav fullWidth:true /]

[Header
  title:`["Unraveling", "The JPEG"]`
  longTitle:`["Unraveling", "The JPEG"]`
  date:"April 15, 2019"
  dek:"JPEG images are everywhere, yet how they work remains a mystery to most. The secret is getting rid of almost unnoticeable details to get the smallest filesize - but what does that look like? Let's see what our eyes can't see."
  fullWidth:true
  authors:`[{
    name: "Omar Shehata",
    role: ''
  }]`
  doi:""
  archive:""
  source:""
/]

// IDEA for the header: It should be a pre-computed image at various stages of % of cosine waves, and either as you scroll down, or as you hover, it goes from 100% to 0.0001%. It would look super cool!


What's most impressive about JPEG is how ubiquitous it is. It is taken for granted that you can send a picture to a friend without worrying about what device, browser, or operating system they're using. It wasn't always this way, and this was exactly the reason the Joint Photographic Experts Group (JPEG) was established in 1986. Their goal was to create a way of sending and storing images that we can all agree on. It had to be both efficient and easy enough to implement to be widely supported.

Since you've used the internet, you've probably seen a JPEG image. JPEG is a standard for digital image compression that's enabled a world where colorful, high quality images can easily be shared. From web pages, to email, to social media, JPEG images are used billions of times per day -- almost every time images are viewed or sent online. Without JPEG, the web would be a little less colorful, a lot slower, and have far fewer cat pictures.

This article will cover the JPEG by cracking open an image and letting you play with its raw bytes. The goal is to show what it takes to go from the ones and zeros stored on your computer to the images that appeare on your screen. The technology is worth learning about not just because it's used across the globe everyday: as the layers of compressions are unraveled, you'll learn a little bit about yourself, and about what details your eyes are most sensitive to.
// Along the way we'll also encounter some very fascinating mathematics, like how to represent an image as a sum of waves, and why you'd ever want to do that!

It's also just a lot of fun to play with images this way:

[img src:"static/images/glitchy-cat.gif"/]
[br/]

// What's most impressive about JPEG is how ubiquitous it is. It is taken for granted that you can send a picture to a friend without worrying about what device, browser, or operating system they're using. It wasn't always this way, and this was exactly the reason the Joint Photographic Experts Group (JPEG) was established in 1986. Their goal was to create a way of sending and storing images that we can all agree on. It had to be both efficient and easy enough to implement to be widely supported.

// Let's see what they came up with.

## Peering Inside a JPEG

Everything on a computer is stored as a series of binary numbers. Typically these bits, the 0's and 1's, are arranged in groups of 8, known as bytes. When you open a JPEG image on your computer, something has to decode the bytes (the browser, your operating system or something else) to recover the original image as a list of colors that can then be displayed.

// Being able to see and manipulate them might give us some clues into how it works. This will also give us a way to verify that we've learned does indeed apply to a real image.

// Here's the JPEG from before:

Take a typical JPEG image as you might encounter on the internet:

[img src:"static/images/blanket-cat.jpg"/]
[br/]

If you download and open this image using any [Reference content:"Here I'm using <a href='https://notepad-plus-plus.org/'>Notepad++</a> to edit the file, since common text editors like Windows' Notepad will change the file's binary contents when you save it so it's no longer a valid JPEG."]text editor[/Reference], you'll see a bunch of garbled characters.

[img src:"static/images/blanket-cat-notepad.png"/]
[br/]

By opening an image in a text editor, we've confused the computer in the same way you confuse your brain when you rub your eyes really hard!

[a href:"https://en.wikipedia.org/wiki/Phosphene"]Phosphenes[/a] is the phenomenon of seeing patterns of light that aren't there. It happens because your brain assumes that any electrical signal arriving through the nerves in your eye is conveying light information. It needs to make this assumption because there's no way to know whether a given signal is sound, sight, or something else. All the nerves in your body carry exactly the same type of electrical pulse. When you apply pressure by rubbing your eyes, you're sending non-visual signals that trigger the receptors in your eye, and your brain incorrectly interprets that as vision.

This is a useful analogy not just because it's fun to think of ways computers are similar to our brains, but it also illustrates how data, whether carried through a body by nerves, or stored in a computer, has no intrinsic meaning. It's how you interpret it that gives it meaning. This is exactly what's happening here. Just like with the signals in your nerves, all binary data looks the same (it's all 0's and 1's) and could be conveying any kind of information. Your computer often guesses how to interpret it using clues like the file extension. Here we've forced it to interpret it as text because that's what a text editor expects.

The goal is to be able to see the original signals themselves, the binary data. That could be done with a [Reference content:"You don't necessarily _need_ a hex editor. You can edit the characters as text, save the file, and re-open it as an image just fine. Try removing the * in line 10 for example and see what happens. But since our goal is to understand how JPEG stores images, it's helpful to be able to actually read the bits!"]hex editor[/Reference]. Or it could be done right in this webpage. Below is the image next to all of its bytes, represented as decimal numbers. You can make changes to the bytes and it will re-decode and display the image as you type.

[RawEditor ref:"Raw1" fullWidth:true imageUrl:"static/images/blanket-cat.jpg" /]

[br/]

[aside]
_Hint: try scrolling down and removing a few chunks. Don't worry, you can always reset the image back to the original!_
[/aside]
There's a lot to be learned just from playing around with this editor. For example, can you figure out the order the pixels are stored in?

Something strange in the example above is that changing some numbers doesn't seem to impact the image at all, while [EditorLink editor:`refs.Raw1` line:39 search:' 17 ' replace:' 0 ']setting the 17 on line 39 to 0[/EditorLink] completely ruins the image! Others like [EditorLink editor:`refs.Raw1` line:2026 search:' 7 ' replace:' 254 ']setting the 7 on line 2026 to 254[/EditorLink] change the color but only for subsequent pixels.

Perhaps what's most peculiar is that some numbers change not just the color but the shape of the image as well. Change [EditorLink editor:`refs.Raw1` line:50 search:' 70 ' replace:' 2 ']70 to 2 in line 50[/EditorLink] and look at the top row of the image to see what I mean. You'll always find these mysterious checkboard patterns lurking regardless of what JPEG you're using.

// If you wanna see something REALLY crazy, find 255 192, skip 5 numbers, then subtract 1
// Or change 188 to 181 in line 11

[aside]
### The three layers of JPEG compression
1. Chrominance Subsampling
2. Discrete Cosine Transform & Quantization
3. Huffman, Run-Length & Delta Encoding
[/aside]

It's hard to decipher the relationship between the bytes and the image because JPEG compression is actually composed of 3 independent compression techniques, applied in successive layers. We'll look at each of these layers of compression separately to unravel this mysterious behavior we're seeing.

// The first two are **lossy** techniques - they throw away information to make the file size smaller. We'll look at each one separately to see how it contributes to the total compression.

// Before I explain each one, I'll give you a chance to figure it out yourself, using clues like knowing how small the JPEG version of the image is, or just by observing how the JPEG behaves when edited. Putting yourself in the shoes of the inventor like this is a great way not just to learn , but as we'll see, sometimes even invent something better!

To give an idea of the scale of this compression, the image above is representing using exactly 79,819 numbers,
// (TODO: Compute automatically?)
 , which makes it about 79 kilobytes. If it were stored with no compression, 3 numbers would be needed for each pixel -- one for each of the red, green and blue components. That would mean a total of 917,700 numbers, or about 917 kilobytes. With the JPEG compression, the resulting file is over ten times smaller!

In fact that image can be made even smaller. It can be squeezed into just 16 kilobytes by using more aggressive compression (that's 57 times smaller than uncompressed). This was re-exported with a quality of 20% using the software program Gimp. If you look closely you'll see some detail has been lost from the original image.
// TODO - say something about what it means to turn up compression?

[RawEditor ref:"Raw2" fullWidth:true imageUrl:"static/images/blanket-cat-small.jpg" /]
// TODO - i think just show an image here, no editor, and let people focus on comparing the compression differences. maybe even show the two side-by-side?

The checkboard patterns are even more obvious now when we change the [EditorLink editor:`refs.Raw2` line:188 search:' 111 ' replace:' 0 ']111 on line 118 to 0[/EditorLink].
// TODO - this sentence doesn't make sense anymore because we haven't introduced the checkerboard patterns.

## Part 1 - Chrominance Subsampling

Here's the same image with just the first layer of compression applied.

[ChromaEditor ref:"Chroma1" imageUrl:"static/images/blanket-cat-smallest.jpg" /]

It's a little more straightforward to decipher now. It's almost a simple list of colors, where each byte changes exactly one pixel, and yet it's already ~3x smaller than the uncompressed size. Can you guess why?

_Hint: Notice that removing one number ruins all the colors. But removing exactly 6, or any multiple of 6, has a minimal effect on the image._
[br/]

Here's another hint: If the numbers [EditorLink editor:`refs.Chroma1` pattern:'zero-all']are all replaced with 0[/EditorLink], the image turns green, not black, as you might expect if those bytes represented red, green and blue components.

This is because the bytes represent the [EditorLink editor:`refs.Chroma1` pattern:'isolate-Y' scale:4]Y[/EditorLink] (brightness), [EditorLink editor:`refs.Chroma1` pattern:'isolate-Cb' scale:4]Cb[/EditorLink] (blueness), and [EditorLink editor:`refs.Chroma1` pattern:'isolate-Cr' scale:4]Cr[/EditorLink] (redness) of the image.

So why not just use RGB? After all, that's how most modern screens work. Your monitor can display any color by turning on red, green and blue lights at various intensities for each pixel. The color white is displayed by turning on all 3 colors at full brightness, while black is displayed by turning them all off.

[br/]
[img src:"static/images/BlackWhiteGray_Purdue.gif"/]
[caption]Credit: http://www.chem.purdue.edu/jmol/cchem/RGBColors/body_rgbcolors.html [/caption]
[br/]

That's also very similar to how human eyes work. The color receptors in our eyes are called cones. They're split into 3 types that are most sensitive to red, green or blue. Rods are the other type of receptor that people have in their eyes. They don't detect color, but they're far more sensitive, and we each have about 120 million of them, compared to a measly 6 million cones.

This means our eyes are a lot more sensitive to changes in brightness than they are to changes in color. If the color can be separated from the brightness, a bit of the color can be thrown away without anyone noticing. This is exactly what JPEG does! To get the image to be 3x as small, the Y component of each pixel is stored, but only the average Cb and Cr for each 4 pixels are stored.

That's why removing 1 number completely ruins the color. The components are stored as **Y Y Y Y Cb Cr**. Removing the first number would cause the Cb value to be interpreted as Y, the Cr as Cb, and create this rippling effect, flipping all the colors across the image.

What if a different component had been downsampled? Our eyes are not equally sensitive to all colors. Of the 6 millions cones, about 64% are most sensitive to red, 32% to green, and just 2% to blue. JPEG claims that this is the best way, but let's test this for ourselves.

[img src:"static/images/YCbCr.png"/]
_TODO: Make this interactive. A slider will allow you to adjust the scaling factor. When at 100%, all images look identical, because all images will be using all the components. As you move the slider, we fix the one component, and scale down the other two. You'll see how the one that looks best by far is the bottom left, black and white one_.
[br/]

Downsampling the color gives us an easy way to get the image 3x smaller, but there is a long way to go to get to 57x smaller. Plus, this wouldn't give us any gain if the image was already black and white. There's got to be a lot more that can be throw away.

## Part 2 - Discrete Cosine Transform & Quantization

The second layer of compression is the most fascinating. It's largely the defining feature of JPEG. After the colors are converted to YCbCr, the components are compressed individually. Here's what the bytes for the Y component look like with this layer applied.

[DctEditor ref:"DCT1" comp:"Y" imageUrl:"static/images/blanket-cat-smallest.jpg" /]

At first glance, this seems like very poor compression. There are 100,000 pixels in this image, and yet it takes 102,400 numbers to represent the luminance of each pixel using this layer of compression - that's worse than not compressing it at all!

But notice that most of these values are 0. In fact, [EditorLink editor:`refs.DCT1` pattern:"remove-zeros"]all of these zeros can be removed[/EditorLink] and only ~23,000 numbers are left, which makes it about 4x smaller!

In this layer lies the secret to the checkboard patterns. Unlike the other effects so far, the appearance of these patterns is not a glitch. They are in fact the building blocks of the entire image! Every line in the editor contains exactly 64 numbers, known as the Discrete Cosine Transform (DCT) coefficients, which correspond to intensities of 64 unique patterns.

You can see each of these patterns by zeroing out all but one of the numbers in any line. Here's an image that shows all of them individually.

[DctEditor ref:"DCT2" imageUrl:"static/images/DCTGrid.jpg" override:"254 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 254 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 254 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 254 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 254 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 254 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 254 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 254 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 254 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 254 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 254 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 254 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 254 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 254 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 254 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 254 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 254 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 254 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 254 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 254 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 254 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 254 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 254 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 254 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 254 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 254 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 254 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 254 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 254 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 254 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 254 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 254 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 254 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 254 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 254 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 254 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 254 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 254 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 254 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 254 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 254 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 254 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 254 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 254 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 254 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 254 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 254 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 254 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 254 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 254 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 254 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 254 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 254 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 254 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 254 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 254 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 254 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 254 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 254 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 254 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 254 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 254 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 254 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 254"/]

These patterns are special because they form a basis for 8x8 images. If you're not familiar with linear algebra, what that means is that any 8x8 image, anything at all that you can image, can be made out of these specific 64 patterns. The Discrete Cosine Transform is the process of converting the colors of an image to these 64 coefficients.

If you're not convinced (I wasn't when I first heard this!) you can see this for yourself. Go back to the image at the start of this section. You can click on any pixel (the eyes are a good one to try) and it'll show you what line in the editor has its bytes. Start removing numbers from the end of the line and watch what happens to the shape of the pixels. Another way is to increase the values to make it more obvious which pattern it is and how they each contribute to the image you see.

It might seem a little magical to be able to say that any image can be represented using 64 specific patterns. But this is the same thing as saying only two numbers are needed to represent any location on the surface of the globe: longitude and latitude. The surface of the Earth is 2 dimensional, so two numbers are needed. An 8x8 image is 64 dimensional, so it requires 64 numbers.

In terms of compression, it's not obvious how this helps. If 64 numbers are needed to represent an 8x8 image, why is this better than storing the 64 luminance components? For the same reason converting from the 3 numbers of RGB to the 3 numbers of YCbCr helped: it enables the removal of details that are less noticeable.

While JPEG only applies the Discrete Cosine Transform to blocks of 8x8 pixels at a time, but there's no reason it can't be applied it to the whole image, which will make it easier to see. Here's what it looks like applied to the Y component of the entire image.

[FullDctEditor ref:"DCT3" imageUrl:"static/images/blanket-cat-smallest.jpg"/]

Over [EditorLink editor:`refs.DCT3` pattern:"remove-{170}"]60,000 numbers can be removed[/EditorLink] from the end with almost no noticable change. But notice that if [EditorLink editor:`refs.DCT3` pattern:"zero-{5}"]just the first five numbers are zeroed out[/EditorLink] (ignoring the first because it just makes the image darker) there's already an obvious change.

The patterns at the beginning represent the low frequency changes in the image, which our eyes are more sensitive to, while numbers towards the end represent the high frequency changes, which we're less sensitive to, so we don't notice when they're gone. I promised I'd show you what that looks like, so here's the image with the [EditorLink editor:`refs.DCT3` pattern:"zero-{5000}"]first 5000 numbers zeroed out[/EditorLink].

What you're looking at here is all the areas of the image that have the greatest change from one pixel to the next. The cat's eyes, whiskers, fuzzy blanket and shadows on the bottom left all stand out. This can be taken even further, to [EditorLink editor:`refs.DCT3` pattern:"zero-{10000}"]zeroeing out the first 10,000[/EditorLink] numbers, to [EditorLink editor:`refs.DCT3` pattern:"zero-{20000}"]20,000[/EditorLink], to [EditorLink editor:`refs.DCT3` pattern:"zero-{40000}"]40,000[/EditorLink] and [EditorLink editor:`refs.DCT3` pattern:"zero-{60000}"]60,000[/EditorLink].

What you're looking at is what JPEG removes during this compression step. The Discrete Cosine Transform itself is not lossy. It's the quantization of these numbers, where we remove the small values closer to the end, that's lossy. The lower the quality, the more numbers we remove, the greater the compression.
// TODO - add a callback to the "amount of compression" referenced in the earlier section

// TODO: Mention that quantization is to map these values back to the 0-255 range.
// Hypothesis: images with text have lots of high frequency changes. We can prove this now! This makes sense because JPEG was made for images.

Just for fun, here's what it looks like [EditorLink editor:`refs.DCT3` pattern:"remove-{268}"]using just 24,000 numbers[/EditorLink], and [EditorLink editor:`refs.DCT3` pattern:"remove-{316}"]just 5000 numbers[/EditorLink]. Pretty blurry, but almost recognizable!

// A very similar technique is the [a href:"http://www.jezzamon.com/fourier/"]fourier transform[/a]. It's used in audio too!

// How does DCT work? Here's the equation. We can plug in the numbers. I don't really want to talk about this unless I can graph the functions, in 3D?

## Part 3 - Huffman, Run-Length & Delta Encoding

Downsampling the color components gives about 3 times compression, and throwing away high frequency data gives about 4 times compression. Together these two techniques give a 12x compression. To squeeze the bytes into an even smaller space, there's a few more tricks that can be applied. These aren't unique to JPEG, these are general data compression techniques. This layer is different from everything before in that it's lossless - no data is thrown away here.

**Run-length encoding** takes repeated values and expresses them more concisely. As shown earlier, there are a lot of 0's in the DCT coefficients. This data was "thrown away" by setting it to 0, but a 0 is still a number, and it takes just as much space as any other number. Since there's always going to be a long string of 0's at the end of each block, it can be expressed more efficiently by saying "there are 15 zeroes". This can be communicated using 2 numbers, instead of 15.

**Delta encoding** is when you represent values relative to the previous value instead of as absolute values. Consider the list of numbers below.

```
12 13 14 16 17 18 19 20
```

Delta-encoding starts with 12, but then everything after would be how much you need to add to get the next number. So it would look like:

```
12 1 1 2 1 1 1 1
```

On its own, it's not helpful. But combined with run-length encoding, it can create runs of repeated values that can then be very efficiently stored. This is especially true for image data where the colors aren't expected to change too much between each 8x8 block.

The final step is **Huffman encoding**. This is the reason certain changes to individual bytes completely destroyed the whole image. Huffman encoding is what makes it impossible (or at least incredibly difficult) to decode an image without the header - the first ~200 bytes of any JPEG image that contain metadata like the width and height of the image. It's difficult for the same reason it would be incredibly difficult for you to understand a language I just made up to describe one particular painting. It would likely be very elegant and concise, but probably not very useful for anything other than describing that one, specific, painting.

TODO: Explain how to find the header, and how to change the width and height of the image, as a warm up to this.

This is, more or less, how Huffman encoding works! This might sound ridiculous, but these numbers are indeed a dictionary for a made up language-of-sorts unique to this particular image!

// [EditorLink editor:`refs.Huffman1` line:39 search:' 17 ' replace:' 0 '][/EditorLink]
// [RawEditor ref:"Huffman1" fullWidth:true imageUrl:"static/images/blanket-cat-small.jpg" /]

The "255 196" byte pair marks the definition of a Huffman encoding table. It tells us how to read the bytes in the JPEG.

Why would you want to create a unique dictionary for each image like this? Imagine that after all of our compression layers, our final bytes looked like this:

```
1 1 1 255 1 1
```

These are 6 decimal numbers. In binary, these are stored as:

```
00000001 00000001 00000001 11111111 00000001 00000001
```

That's a total of 48 bits. 8 bits are used per number so that numbers up to 255 can be stored, but that means 7 bits are wasted on almost all of the numbers here. Ideally, every number would be stored in as many bits it needs and no more. So it would be:

```
1   1   1   11111111    1   1
```

This is now only 13 bits. This made our data over 3x as small, just by removing unnecessary bits, with no change to the image quality!

There's one problem though - I deliberately spaced out the numbers when showing it so you'd know where each one starts and ends. But if you were a computed reading the bits of a file, this is what you'd see:

```
1111111111111
```

These are the 13 bits. Is the first number a 1? Or is it a 11 (a 3 in decimal)? Or is it a 11111111? The needs to be a way to know how many bits to read for each number.

This is a fun problem to try and solve with many creative solutions. For example, you could say you'll put a stop marker in there, maybe it's "0". But then you have to figure out a way to represent "0"! It's outside the scope of this article, but Huffman encoding is the answer. It is the most efficient way of packing a string of bits without using start/stop markers. There are many good explanations on it, one of my favorite is [a href:"https://www.youtube.com/watch?v=JsTptu56GM8"]Tom Scott's video[/a] on how it works for text compression.

[hr/]

I hope this makes you appreciate all the work that goes into it viewing even a simple cat picture! But this knowledge is valuable, (myth of jpeg resaving?) or now you can "hide" a JPEG by chopping off the header (which is what facebook does!) or even cooler, change the quantization table so that it looks like a valid JPEG, but it doesn't look like much, unless you use your special quantization table key!

## (OPTIONAL) Epilogue - Getting a Single Color Out of JPEG

TODO: If there's no time, we can just cut this. Although it would be really neat as a way to tie it all together.

I promised we'll understand exactly how to decode a JPEG. Here, if you click on a pixel, it'll:

* Tell you the Huffman value? Then decode it (can I create a map to get this? Would be hard otherwise given the variable length encoding)
* Tell you the 64 coefficients in the MCU block
* Tell you the YCbCr value
* Tell you the RGB value

// - Add tabs to the editor
// - Make reset not change where you scroll
// -
// - Make editor link highlight what it changes? And clear highlight on reset or clicking another link
// - Scrolling issue, when you scroll through the editor it scroll the page
// - (temporary fix right now) Fix the flicker with "image corrupted when you click on link"
// - Doing ctrl+h to find and replace will hang the editor
// - Make fullDct work with colors?