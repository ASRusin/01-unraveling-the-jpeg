[meta title:"Unraveling The JPEG" description:"JPEG images are everywhere, yet how they work remains a mystery to most. The secret is getting rid of almost unnoticeable details to get the smallest filesize - but what does that look like? Let's see what our eyes can't see." /]

[Nav fullWidth:true /]

[Header
  title:`["Unraveling", "The JPEG"]`
  longTitle:`["Unraveling", "The JPEG"]`
  date:"April 15, 2019"
  dek:"JPEG images are everywhere, but how do they work? The secret is getting rid of almost unnoticeable details to get the smallest filesize — but what does that look like? Let's see what our eyes can't see!"
  fullWidth:true
  authors:`[{
    name: "Omar Shehata",
    role: ''
  }]`
  doi:""
  archive:""
  source:""
/]

It's easy to take it for granted that you can send a picture to a friend without worrying about what device, browser, or operating system they’re using, but things weren’t always this way. By the early 1980's, computers could store and display digital images, but there were many competing ideas about how best to do that, so you couldn't just send an image from one computer to another and expect it to work. To solve this problem, the Joint Photographic Experts Group (JPEG), a committee of experts from all over the world, was established in 1986 as a joint effort by the ISO and the IEC — two international standards organizations headquartered in Geneva, Switzerland.

JPEG, the group of people, created JPEG, a standard for digital image compression in 1992. Anyone who's ever used the internet has probably seen a JPEG-encoded image. It is by far the most ubiquitous way of encoding, sending and storing images. From web pages to email to social media, JPEGs are used billions of times a day — almost every time we view or send images online. Without JPEG, the web would be a little less colorful, a lot slower, and probably have far fewer cat pictures!

This article is about how to decode a JPEG image. Or in other words, it's about what it takes to convert the compressed data stored on your computer to the image that appears on the screen. It's worth learning about not just because it's important to understand the technology we all use everyday, but as we unravel the layers of compression, we learn a bit about perception and vision, and about what details our eyes are most sensitive to. 

It's also just a lot of fun to play with images this way.

[br/]

[FullWidth]
[img style:`{width: '100%'}` src:"static/images/glitchy-cat.gif"/]
[/FullWidth]

[br/]

## Peering Inside a JPEG

Everything on a computer is stored as a series of binary numbers. Typically, these bits, the zeroes and ones, are arranged in groups of eight, known as bytes. When you open a JPEG image on your computer, something (the browser, your operating system, or something else) has to decode the bytes to recover the original image as a list of colors that can then be displayed.

If you download [Reference content:"The adorable kitten image used in this article was taken by <a href='https://unsplash.com/photos/NodtnCsLdTE'>Mikhail Vasilyev on Unplash</a>"]that picture of the cat[/Reference] and open it using any text editor, you'll see a bunch of garbled characters.

[Right fullWidth:true]
  [img src:"static/images/blanket-cat-notepad.png"/]
  [caption]
    Here I'm using [Notepad++](https://notepad-plus-plus.org/) to edit the file, since common text editors like Windows' Notepad will change the file's binary contents when you save it so it's no longer a valid JPEG.
  [/caption]
[/Right]

[br/]

By opening an image in a text editor, you’ve confused the computer, in the same way you confuse your brain when you rub your eyes too hard and start to see blotches of dimness and color!

These blotches you see — known as [a href:"https://en.wikipedia.org/wiki/Phosphene"]“phosphenes”[/a] — don't come from any light stimulus, nor are they hallucinations made up in your mind. They arise because your brain assumes that any electrical signal arriving through the nerves in your eye is conveying light information. The brain needs to make this assumption because there’s no way to know whether a given signal is sound, sight, or something else. All the nerves in your body carry exactly the same type of electrical pulse. When you apply pressure by rubbing your eyes, you’re sending non-visual signals that trigger the receptors in your eye, which your brain interprets — incorrectly, in this case — as vision. You can literally see the pressure!

It’s fun to think about how similar computers are to our brains, but this is also a useful analogy because it illustrates how much the meaning of data — whether carried through a body by nerves, or stored in a computer — relies on how you interpret it. All binary data is made up of ones and zeroes, basic components that could be conveying any kind of information. Your computer often guesses how to interpret it using clues, like the file extension. Here we’ve forced it to interpret it as text, because that’s what a text editor expects.

To understand how a JPEG image is decoded we need to see the original signals themselves — the binary data. This can be done with a [Tooltip content:"You don't necessarily <i>need</i> a hex editor. You can edit the characters as text, save the file, and re-open it as an image just fine. But since our goal is to understand how JPEG stores images, it's helpful to be able to actually read the bytes!"]hex editor[/Tooltip]; or it can be done right here in this webpage! Below is the image next to [Tooltip content:"The only thing omitted here is the header, which is the first ~200 bytes that contain metadata like the width and height of the image. We'll revist this later in the article."]all of its bytes[/Tooltip], represented as decimal numbers. You can make changes to the bytes, and it will re-decode and display the new, edited image as you type.

[RawEditor ref:"Raw1" fullWidth:true imageUrl:"static/images/blanket-cat.jpg" showHeader:false /]

[br/]

[aside]
_Hint: try scrolling down and removing a few chunks. Don't worry, you can always reset the image back to the original!_[br/]
[/aside]

There's a lot you can learn just from playing around with this editor. For example, can you figure out the order the pixels are stored in?

Something strange in the example above is that changing some numbers doesn't seem to impact the image at all, while [EditorLink editor:`refs.Raw1` line:1 search:' 17 ' replace:' 0 ']setting the 17 on line 1 to 0[/EditorLink] completely ruins the image! Other actions, like [EditorLink editor:`refs.Raw1` line:1988 search:' 7 ' replace:' 254 ']setting the 7 on line 1988 to 254[/EditorLink] change the color, but only for subsequent pixels.

Perhaps what's most peculiar is that some numbers change not just the color but the shape of the image as well. Change the [EditorLink editor:`refs.Raw1` line:12 search:' 70 ' replace:' 2 ']70 in line 12 to 2[/EditorLink] and look at the top row of the image to see what I mean. You'll always find these mysterious checkboard patterns lurking regardless of what JPEG you're using.

It's hard to decipher how the image can be reconstructed from these bytes by playing around like this, because JPEG compression is actually composed of 3 different compression techniques, which are applied in successive layers. We'll look at each of these layers of compression separately to unravel this mysterious behavior we're seeing.


[inset]

### The three layers of JPEG compression
1. Chrominance Subsampling
2. Discrete Cosine Transform & Quantization
3. Huffman, Run-Length & Delta Encoding

[/inset]

To give you an idea of the scale of this compression, notice that the image above is represented using exactly 79,819 numbers, which makes it about 79 kilobytes. If it were stored with no compression, 3 numbers would be needed for each pixel — one for each of the red, green and blue components. That would mean a total of 917,700 numbers, or about 917 kilobytes. With JPEG compression, the resulting file is over **ten times smaller**!

In fact, this image can be squeezed into far fewer bytes. Below is the image next to a version of it that was compressed down to just 16 kilobytes, which makes it **fifty seven times smaller** than the uncompressed version would be!

[img src:"static/images/compression-comparison.png"/]
[br/]

If you look closely you'll see that these images are not identical. Both are JPEG-encoded images, but the one on the right is much smaller in terms of filesize. It also doesn't look as nice (notice how blocky the colors look in the background). The fact that the image changes and loses some detail when we compress it is what makes JPEG a **lossy compression** technique.

## Part 1 - Chrominance Subsampling

Here's the image with just the first layer of compression applied.

[ChromaEditor ref:"Chroma1" imageUrl:"static/images/blanket-cat-smallest.jpg" /]

[aside]
_Hint: Notice that removing one number ruins all the colors. But removing exactly 6, or any multiple of 6, has a minimal effect on the image._[br/]
[/aside]

It's a little more straightforward to decipher now. It's almost a simple list of colors, where each byte changes exactly one pixel, and yet it's already almost twice as small as the uncompressed image (which would be ~300 kb for this smaller size). Can you guess why?

You can tell that these numbers don't represent the standard red, green and blue components because [EditorLink editor:`refs.Chroma1` pattern:'zero-all']replacing all the numbers with 0[/EditorLink] turns the image green (as opposed to black). 

This is because these bytes represent the [EditorLink editor:`refs.Chroma1` pattern:'isolate-Y' scale:4]Y[/EditorLink] (brightness), [EditorLink editor:`refs.Chroma1` pattern:'isolate-Cb' scale:4]Cb[/EditorLink] (relative blueness), and [EditorLink editor:`refs.Chroma1` pattern:'isolate-Cr' scale:4]Cr[/EditorLink] (relative redness) of the image.

Why not just use RGB? After all, that's how most modern screens work. Your monitor can display any color by turning on red, green and blue lights at various intensities for each pixel. White is displayed by turning on all 3 colors at full brightness, while black is displayed by turning them all off.

[br/]
[img src:"static/images/BlackWhiteGray_Purdue.gif"/]
[caption]Credit: http://www.chem.purdue.edu/jmol/cchem/RGBColors/body_rgbcolors.html [/caption]
[br/]

That's also very similar to how human eyes work. The color receptors in our eyes known as “cones” are split into three types, each of which is mostly sensitive either to red, green, or blue. Rods, the other type of receptor we have in our eyes, can only detect changes in brightness, but they’re far more sensitive, and we have about one hundred and twenty million of them, compared to a measly six million cones.

This means that our eyes are much better at detecting changes in brightness than they are at detecting changes in color. If we can separate the color from the brightness, we can throw away a bit of the color without anyone noticing. This is exactly what chrominance subsampling is. In the example above, each pixel has one Y component, while each 4 pixels share one Cb and one Cr, so the image contains only a quarter as much color information as it originally did. 

[aside]
Using the YCbCr colorspace is not unique to JPEG. In fact, it was originally developed in 1938 (TODO MAKE THIS  ALINK https://en.wikipedia.org/wiki/GeorgesValensi ) for TV broadcasts. Not everyone had color TVs, so separating out the color from the luminance allowed everyone to receive the same transmission, and TVs that didn't support color would just use the luminance component.
[/aside]

This is why removing 1 number from the diagram above completely ruins the color. Here, the [Tooltip content:"In general, JPEG images don't store the components in any particular order. They might be interleaved like in this example, or all the Y components of the image could be stored, followed by all the Cb etc. The header of the JPEG is what tells us how the components are stored."]components are stored[/Tooltip] as **Y Y Y Y Cb Cr**. Removing the first number causes the Cb value to be interpreted as Y, the Cr as Cb, and creates a ripple effect that flips all the colors across the image.

There's nothing in the JPEG specification that says you must use YCbCr, or that you can't subsample the Y component. You can see for yourself in the diagram below what it would look to subsample each component individually. This is actually the type of experiment conducted to figure out which colors our eyes are most sensitive to.

[var name:"subsamplePercent" value:0.15 /]
[SubsampleGrid imageUrl:"static/images/blanket-cat-tiny.jpg" subsamplePercent:`subsamplePercent` /]
[Range value:subsamplePercent min:0 max:1 step:0.05 /]

[aside]
Removing a bit of blue isn't as noticeable as removing red or green. This is because of the six million cones you have in your eyes, about 64% are most sensitive to red, 32% to green, and only 2% to blue.
[/aside]

Subsampling the Y component (bottom left) has the greatest effect on the image quality. Even a tiny bit is already noticable. You can move the slider to see how removing a greater % of each component affects the image. 

Representing an image in the YCbCr colorspace doesn't in itself make it any smaller than using RGB, but it allows us to more easily pick out less noticeable details to throw away (in this case, color). This idea of finding new ways to represent data to make it more compressible is very common in compression techniques, and is at the heart of what the next layer does.

## Part 2 - Discrete Cosine Transform & Quantization

This layer of compression is largely the defining feature of JPEG. After the colors are converted to YCbCr, the components are compressed individually, so we can focus on just the Y component for the rest of the article. Here's what the bytes for the Y component look like with this layer applied.

[DctEditor ref:"DCT1" comp:"Y" imageUrl:"static/images/blanket-cat-smallest.jpg" /]

[aside]
Hint: Try clicking on any pixel in the image to see the line in the editor that represents it. Try removing numbers from the end, or adding a few zero's to any individual number to make its effect more obvious.
[/aside]

At first glance, this seems like very poor compression. There are 100,000 pixels in this image, and yet it takes 102,400 numbers to represent the luminance of each pixel — that's worse than not compressing it at all!

But notice that most of these values are 0. In fact, [EditorLink editor:`refs.DCT1` pattern:"remove-zeros"]all of these zeros can be removed[/EditorLink] with no change to the image. This leaves only ~23,000 numbers, which makes it about 4x smaller!

In this layer lies the secret to the checkerboard patterns. Unlike the other effects we've seen, the appearance of these patterns is not a glitch. They are in fact the building blocks of the entire image! Every line in the editor above contains exactly 64 numbers, known as the Discrete Cosine Transform (DCT) coefficients, which correspond to intensities of 64 unique patterns.

You can see each of these patterns by zeroing out all but one of the numbers in any line. Here's an image that shows all 64 of them individually.

[data name:"DCT-grid" source:"DCT-grid.json" /]
[data name:"DCT-circle" source:"DCT-circle.json" /]
[data name:"DCT-eye" source:"DCT-eye.json" /]
[DctEditor  ref:"DCT2" imageUrl:"static/images/DCTGrid.jpg" override:DCT-grid/]

These patterns are special because they form a basis for 8x8 images. If you're not familiar with linear algebra, what that means is that any 8x8 image, anything at all that you can imagine, can be made out of these specific 64 patterns. The Discrete Cosine Transform is the process of converting the colors of an image to these 64 coefficients. Here's [EditorLink editor:`refs.DCT2` pattern:"animate-DCT" DCT:DCT-circle]how you would form a circle[/EditorLink] by combining these patterns, or [EditorLink editor:`refs.DCT2` pattern:"animate-DCT" DCT:DCT-eye]the cat's face[/EditorLink]. You can [EditorLink editor:`refs.DCT2` pattern:"animate-DCT" DCT:DCT-grid]click here to go back to the grid of 64 patterns[/EditorLink].

It seems like magic to say that any image can be represented using 64 specific patterns. But this is the same thing as saying any location on the Earth can be represented using only two numbers: longitude and latitude. The surface of the Earth is two-dimensional, so two numbers are needed. An 8 x 8 image is sixty-four-dimensional, so we need sixty-four numbers.

In terms of compression, it’s not obvious how this helps us. If we need sixty-four numbers to represent an 8 x 8 image, why is this better than storing the sixty-four luminance components? For the same reason we converted from the three numbers of RGB to the three numbers of YCbCr: it allows us to remove detail that’s less noticeable.

While JPEG only applies the Discrete Cosine Transform to blocks of 8 x 8 pixels at a time, there’s no reason we can’t apply it to the whole image. Here’s what it looks like applied to the Y component of the entire image:

[FullDctEditor ref:"DCT3" imageUrl:"static/images/blanket-cat-smallest.jpg"/]

We can [EditorLink editor:`refs.DCT3` pattern:"remove-{170}"]remove over 60,000 numbers[/EditorLink] from the end with almost no noticeable change. But notice that if [EditorLink editor:`refs.DCT3` pattern:"zero-{5}"]we set just the first five numbers to zero[/EditorLink] (ignoring the first because it just makes the image darker) there's already an obvious difference.

The numbers at the beginning represent the lower frequency changes in the image, which our eyes are more sensitive to, while numbers towards the end represent the higher frequency changes, which we're less sensitive to, so we don't notice when they're gone. I promised I'd show you "what our eyes can't see", so let's isolate these high frequency details by setting the [EditorLink editor:`refs.DCT3` pattern:"zero-{5000}"]first 5000 numbers to zero[/EditorLink].

What you're looking at here is all the areas of the image that have the greatest change from one pixel to the next. The cat's eyes, whiskers, fuzzy blanket and shadows on the bottom left all stand out. This can be taken even further, to setting the first [EditorLink editor:`refs.DCT3` pattern:"zero-{10000}"]10,000 numbers to zero[/EditorLink], [EditorLink editor:`refs.DCT3` pattern:"zero-{20000}"]20,000[/EditorLink], [EditorLink editor:`refs.DCT3` pattern:"zero-{40000}"]40,000[/EditorLink] or [EditorLink editor:`refs.DCT3` pattern:"zero-{60000}"]60,000[/EditorLink].

These details are what JPEG removes during this compression step. Converting the colors to the DCT coefficients is not a lossy operation. It's the quantization step that's lossy, where values that are either high frequency, or are close to zero, are removed. The more you remove, the greater the compression, and worse the final quality of the image is. This is why the version of the image in the first section that was 57x smaller looked blocky. Each 8 x 8 block was represented by far fewer DCT coefficients.

[aside]
One really cool thing you can do with this technique is progressively stream images. Imagine seeing a blurry version of the whole image, and slowly seeing it become more and more detailed as the download progresses and more DCT coefficients are available. This is actually possible to do with JPEG, but not as commonly used.
[/aside]

Just for fun, here's what it looks like using just [EditorLink editor:`refs.DCT3` pattern:"remove-{268}"]24,000 numbers[/EditorLink], or just [EditorLink editor:`refs.DCT3` pattern:"remove-{316}"]5000 numbers[/EditorLink]. Pretty blurry, but almost recognizable!

## Part 3 - Huffman, Run-Length & Delta Encoding

TODO: Now that we've removed color, and removed high frequency, the final remaining layer is lossless. It does not remove any more details, but it does make it significantly smaller. Imagine if you had just a completely blank white image. Explain run length and delta with this. Then say the last mystery is why the image gets corrupted sometimes. Here it is with the header. Here's where the huffman tables are. End article with the (1), (2), (3) of how to decode it. Anything can be represented by 0's and 1's. 

[RawEditor ref:"Huffman1" fullWidth:true imageUrl:"static/images/black.jpg" /]

Subsampling the color components gives about 3 times compression, and throwing away high frequency data gives about 4 times compression. Together these two techniques give a 12x compression. To squeeze the bytes into an even smaller space, there's a few more tricks that can be applied. These aren't unique to JPEG, these are general data compression techniques. This layer is different from everything before in that it's lossless - no data is thrown away here.

[RawEditor ref:"Huffman2" fullWidth:true imageUrl:"static/images/blanket-cat.jpg" /]

**Run-length encoding** takes repeated values and expresses them more concisely. As shown earlier, there are a lot of 0's in the DCT coefficients. This data was "thrown away" by setting it to 0, but a 0 is still a number, and it takes just as much space as any other number. Since there's always going to be a long string of 0's at the end of each block, it can be expressed more efficiently by saying "there are 15 zeroes". This can be communicated using 2 numbers, instead of 15.

**Delta encoding** is when you represent values relative to the previous value instead of as absolute values. Consider the list of numbers below.

```
12 13 14 16 17 18 19 20
```

Delta-encoding starts with 12, but then everything after would be how much you need to add to get the next number. So it would look like:

```
12 1 1 2 1 1 1 1
```

On its own, it's not helpful. But combined with run-length encoding, it can create runs of repeated values that can then be very efficiently stored. This is especially true for image data where the colors aren't expected to change too much between each 8x8 block.

The final step is **Huffman encoding**. This is the reason certain changes to individual bytes completely destroyed the whole image. Huffman encoding is what makes it impossible (or at least incredibly difficult) to decode an image without the header - the first ~200 bytes of any JPEG image that contain metadata like the width and height of the image. It's difficult for the same reason it would be incredibly difficult for you to understand a language I just made up to describe one particular painting. It would likely be very elegant and concise, but probably not very useful for anything other than describing that one, specific, painting.

TODO: Explain how to find the header, and how to change the width and height of the image, as a warm up to this.

This is, more or less, how Huffman encoding works! This might sound ridiculous, but these numbers are indeed a dictionary for a made up language-of-sorts unique to this particular image!

// [EditorLink editor:`refs.Huffman1` line:39 search:' 17 ' replace:' 0 '][/EditorLink]
// [RawEditor ref:"Huffman1" fullWidth:true imageUrl:"static/images/blanket-cat-small.jpg" /]

The "255 196" byte pair marks the definition of a Huffman encoding table. It tells us how to read the bytes in the JPEG.

Why would you want to create a unique dictionary for each image like this? Imagine that after all of our compression layers, our final bytes looked like this:

```
1 1 1 255 1 1
```

These are 6 decimal numbers. In binary, these are stored as:

```
00000001 00000001 00000001 11111111 00000001 00000001
```

That's a total of 48 bits. 8 bits are used per number so that numbers up to 255 can be stored, but that means 7 bits are wasted on almost all of the numbers here. Ideally, every number would be stored in as many bits it needs and no more. So it would be:

```
1   1   1   11111111    1   1
```

This is now only 13 bits. This made our data over 3x as small, just by removing unnecessary bits, with no change to the image quality!

There's one problem though - I deliberately spaced out the numbers when showing it so you'd know where each one starts and ends. But if you were a computed reading the bits of a file, this is what you'd see:

```
1111111111111
```

These are the 13 bits. Is the first number a 1? Or is it a 11 (a 3 in decimal)? Or is it a 11111111? The needs to be a way to know how many bits to read for each number.

This is a fun problem to try and solve with many creative solutions. For example, you could say you'll put a stop marker in there, maybe it's "0". But then you have to figure out a way to represent "0"! It's outside the scope of this article, but Huffman encoding is the answer. It is the most efficient way of packing a string of bits without using start/stop markers. There are many good explanations on it, one of my favorite is [a href:"https://www.youtube.com/watch?v=JsTptu56GM8"]Tom Scott's video[/a] on how it works for text compression.

[hr/]

I hope this makes you appreciate all the work that goes into it viewing even a simple cat picture! But this knowledge is valuable, (myth of jpeg resaving?) or now you can "hide" a JPEG by chopping off the header (which is what facebook does!) or even cooler, change the quantization table so that it looks like a valid JPEG, but it doesn't look like much, unless you use your special quantization table key!

[AuthorBio]
**Omar Shehata** is a graphics programmer at Cesium and an Egyptian citizen in Philadelphia, PA.

Edited by Matthew Conlen and Victoria Uren.
[/AuthorBio]

[NextArticle fullWidth:true /]