[meta title:"Unraveling The JPEG" description:"Short description of your project" /]

[Nav fullWidth:true /]

[Header
  title:"Unraveling The JPEG"
  fullWidth:true /]

[Metadata
  fullWidth:true
  authors:`[{
    name: "Omar Shehata",
    role: 'Words, Graphics'
  }, {
    name: "Matthew Conlen",
    role: 'Editor'
  }]`
  doi:""
  archive:""
  source:""
/]

If you've ever used the internet, you've probably seen a JPEG image. JPEG is a standard for image compression that's brought us a world where colorful, high quality images can easily be shared. From web pages, to email, to social media and smartphones, it's used billions of times per day across all of our devices every time we view or send images online. Without JPEG, the web would be a little less colorful, a lot slower, and possibly host a lot less cat pictures.

Despite its ubiquity in our lives, JPEG is often treated as a black box. You might be aware that it's a **lossy** compression technique; it throws away data that we're not likely to notice to reduce file size, but what does that data look like? How does it decide what we will or won't notice? And is that assumption correct all the time? (Spoiler: it's not!)

There's even more mysteries that arise when we look at how JPEG images are stored. If you open a JPEG image in a text editor, you'll see the raw bytes; the list of numbers that represent this image on your computer. Below is an image and its raw bytes.

// I want to communicate to the reader that everything we're doing here, they can do by editing the JPEG themselves, saving it, and opening it. That I'm teaching them here isn't some kind of simplified version, it's really the JPEG itself. All I do is strip the header. But I'm not sure if that explanation is appropriate to put in the intro?

Try changing the first 17 to a 1 or 16. Or try changing the first 232 to 252.

[var name:"header" value:`[]` /]
[var name:"body" value:`[]` /]
[TextArea value:body rows:12 cols:70 /]
[ImageFetch src:"static/images/tanzania.jpg" header:header body:body /]
[ImageCanvas header:header body:body  /]

Changing this single number somehow alters the entire image, and quite spectacularly so! It's not too surprising that changing these numbers will change the colors in the image, but certain numbers seem to change, not the color...but the shape? To see what I mean, try changing the second 69 to 251 or greater and look at the top left corner of the image. These checkboard patterns are always hiding in there, no matter what JPEG image you use.

This article will explore how JPEG works by reverse engineering it. You'll get to unravel each of these mysteries by changing the raw bytes and observing what they do to the image! 

I think learning about JPEG is valuable not just because it's important to understand the technology we use everyday, but also because as we peel off each layer of compression we'll learn about visual perception – what details matter most to our eyes, as well as information theory, and a little bit of linear algebra.

/// Saying information theory and linear algebra gets me excited...would it turn off the casual reader? I started with "visual perception" for this reason, I assume it sounds less daunting/more exciting?
// I don't want to make this intro too long, because I know it's more exciting to jump in, but there are a lot of reasons why it's cool to learn this that'll get revealed in the article, such as:
// 1- Compression & encryption are both intimately related in information theory. So it's not just learning how to reduce the size of images, but also how to encrypt and hide secrets.
// 2- For example, you could make a JPEG image a secret by taking out the quantization table from the header. No one else will be able to open it except for you and whoever you give the "key" to.
// 3- There are some real, practical applications of this. Facebook strips the JPEG header to make their images fit in under 200 bytes.
// 4- The linear algebra part is representing the JPEG as a DCT and that's just super cool because it applies not just to images, but also to sound, and really anything! And there's just something beautiful about being able to use the same technique on anything like that. Should I communicate that more here?

## Why does one number change the entire image? 

Let's look at this effect in a simpler image. Here's a 16x8 image that's just a black square and a white square. See if you can find the number that changes the whole image without corrupting it. 

[var name:"header2" value:`[]` /]
[var name:"body2" value:`[]` /]
[TextArea value:body2 rows:4 cols:50 /]
[ImageFetch src:"static/images/huff_simple.jpg" header:header2 body:body2 /]
[ImageCanvas header:header2 body:body2  /]

The first number that has this property is 252. Changing it to 251 changes the black to white and the white to grey. Other values bring out the checkboard patterns.

To figure out why this is happening, a good general technique when reverse engineering is to try and re-invent the thing you're trying to understand. This is akin to solving a crime by putting yourself in the shoes of the suspect. If you think about where _you_ would have hidden the weapon it might help you find it.

In this case, we know the goal of JPEG is to make the file size smaller – to use less bytes when representing the image. Here's what the black and white image would look like if we represented it as just a list of the color of every pixel.

[br/][br/]_Figure of the same as above, except it's about 16 * 8 * 3 = 384 numbers._ [br/][br/]

That's a lot more numbers. This is storing the color in 3 numbers (red, green, blue), for every pixel (it's a 16x8 image, so there's 16 * 8 = 128 pixels). But we don't _really_ need all that much to describe this simple image. Can you think of a way to represent this image with fewer bytes? For example, one easy way is to use 1 number for the color of each pixel instead of 3 since this image is just black and white.

// Do we need some kind of like, horizontal line break or something to indicate "Don't read on if you're not done thinking yet" ?

The smallest reasonable representation I could think of is 8 numbers: store the color (3 numbers) followed by how many pixels have this color. That'll allow us to store each block of solid color in exactly 4 numbers.

[br/][br/]_Figure of those 4 numbers with the resulting image._ [br/][br/]

We just made up our own format, and it's actually better than JPEG (in this one particular case)! If this were a real image, it would probably be _worse_ than just naively storing all the colors. Do you see why? 

The reason I said this is the "smallest reasonable representation" is because we could technically store any image, no matter how big, in a single number, by simply declaring that the number 0 represents that particular image. When I say "Mona Lisa", I've just communicated an entire image using just 2 words, but obviously, this won't work if I want to communicate images you've never seen before.

Representing large areas that have the same color with 2 numbers instead of storing the color of every single pixel saves a huge amount of bytes. This is known as **Run-length encoding (RLE)** and is used in any situation when you have a lot of repeated values next to each other, not just on images. For example, audio files typically have long moments of silence at the beginning or the end, which would benefit from this way of representing them.

// I want to mention delta-encoding here, but there's no way to justify it without introducing Huffman encoding. So maybe I'll skip that/get back to it later?

You can actually go back and confirm that this is indeed what's happening. Try scrolling down and changing values closer to the bottom. Notice how as you go down in the list of numbers, changing a value only affects subsequent values!

[var name:"header3" value:`[]` /]
[var name:"body3" value:`[]` /]
[TextArea value:body3 rows:12 cols:70 /]
[ImageFetch src:"static/images/tanzania.jpg" header:header3 body:body3 /]
[ImageCanvas header:header3 body:body3  /]

// I think this is really important, when I finish an explanation, that the reader can go and verify this for themselves on a real image, even better if it's an image they drag and drop in. That way they know that they really are learning something applicable, that in this case allows them to do a kind of "magic trick", show their friends that they know how to mess around with the bytes to get a specific effect they know how to control! 

## Why do some changes corrupt the image?

RLE explains why numbers change subsequent colors, but why do some innocuous changes just outright "corrupt" the image? If you haven't seen this already try changing the very first number in any of the figures above. If you tried to open that edited JPEG image, it might say something like:

[img src:"static/images/unsupported_windows.png"/]
_This is what it says in the Windows photo app._[br/][br/]

If these numbers represent colors, we wouldn't expect this to happen unless we did something like set a color to a negative value or something like that. But as we saw earlier, changing a 17 to 15 suddenly made the browser no longer capable of recognizing it as an image.

This is admittedly the hardest part to reverse engineer without looking up the JPEG standard. As promised, before I explain it I'll give you a chance to uncover it yourself. The best hint I can give you is that we need to look at the header. Most articles on editing JPEGs will tell you not to touch it since it mostly contains metadata, like how big the image is, how many bytes to expect, etc. so changing those numbers easily makes the image unreadable.

For example, the first two bytes in the body are the "Start of Image" marker. This is what marks a list of numbers a JPEG image, as opposed to a PNG, or a Word document (contrary to what operating systems might have you believe, the file extension really doesn't matter that much). This is the marker that the browser/photo viewers look for when deciding how to decode these numbers, so if it's not there, it won't know to read it as a JPEG. This is one way of corrupting an image.

However, there is a string of special values in the header that we can always safely change, that will always have the most dramatic effect on the image. Look for a "255 196" pair (you can just CTRL+F this), then skip 19 bytes. The first number after will always have the most dramatic effect on the image, with subsequent numbers having less and less of an effect.

There will always be up to four "255 196" pairs that have different effects.

[var name:"header4" value:`[]` /]
[var name:"body4" value:`[]` /]
Body:[br/]
[TextArea value:body4 rows:12 cols:70 /][br/]
Header:[br/]
[TextArea value:header4 rows:6 cols:70 /]
[ImageFetch src:"static/images/tanzania.jpg" header:header4 body:body4 /]
[ImageCanvas header:header4 body:body4  /]
_In the real thing, this might be nice to have as switching tabs, from header to body, in the same way CodePen lets you have HTML/CSS tabs._[br/]

// I noticed I never actually define "decode". I'd like to do that somewhere since it's a scary term but really just means "know how to read/translate a sequence of numbers".

Without these four "255 196" pairs, and the numbers that follow, it would be practically impossible to decode the JPEG. It would be as if I just made up a new language that was particularly efficient at describing one particular painting. It might be a beautifully concise description, but it wouldn't make sense to anyone else.

This might sound ridiculous, but these numbers are indeed a dictionary for a made up language-of-sorts unique to this particular image!

### Variable Length encoding

The "255 196" byte pair marks the definition of a Huffman encoding table. It tells us how to read the numbers in the JPEG. So if we see a "146" that might be a "12" according to the Huffman table.

// I considered dynamically computing and embedding the Huffman table here, but it doesn't map numbers to numbers, it maps bits to bits, so I think I need to explain the below stuff first.

Why would you want to create a unique dictionary for each image like this? Imagine if you had an image, after doing all your compression, the numbers looked like this:

```
1 1 1 255 1 1
```

These are 6 decimal numbers. In binary, these are stored as:

```
00000001 00000001 00000001 11111111 00000001 00000001
```

That's a total of 48 bits. We use 8 bits per number so that we can store numbers up to 255, but that means we're wasting 7 bits on almost all of our numbers here. Ideally, you'd store every number in as many bits it needs, so it would be:

```
1   1   1   11111111    1   1
```

This is now only 13 bits. We've just made our data over (13/48) 3x as small! That's like taking a 10 MB image, too big for a web page, and squeezing it into 3 MB, just by removing unnecessary bits.

There's one problem though - I deliberately spaced out the numbers when showing it so you'd know where each one starts and ends. But when you're reading bits in a file, this is what you'd get:

```
1111111111111
```

These are the 13 bits. Is the first number a 1? Or is a 11 (so  2 in decimal)? Or is a 11111111?

This is a fun problem to try and solve. For example, you could say you'll put a stop marker in there, maybe it's "0". But then you have to figure out a way to represent "0"! I won't spoil it, but Huffman encoding is the answer. It is the most efficient way of packing a string of bits without using start/stop markers. There are many good explanations on it, [here's](TODO:link to ComputerPhile video?) one of my favorite.

As long as we understand that to make sense out of these numbers, we must first translate them based on the Huffman tables, we can keep going. As an example, for the simple image, here's what the first Huffman table looks like:

[br/][br/]_Embed Huffman table. This would be cool if done dynamically, so you could drag and drop an image and see its table._[br/][br/]

So while the first two numbers look like "X Y", to uncover what they really are, we unpack them into their binary bits:

```
binary bits here
```

And notice that the first sequence is "W" from the table. (We then have to take this and further decode it from another Huffman table, this one not found in the file anywhere, but in the JPEG spec. But this detail isn't that important right now?)

Doing this for the whole image, we get the following representation:

[br/][br/]_Figure of image, same as previous, textbox and image, except now it's all the DCT coefficients_.[br/][br/]

Interested readers can see exactly how to perform this step in the source code.

You might have hoped what we'd have now is finally raw color values, but a few seconds of playing around with the numbers above shows this is not the case. None of the steps we've uncovered so far could have had any data lost or thrown away, they were all **lossless** compression steps. The defining feature of JPEG is its lossy nature, so there's bound to be more to the story.

// I'll have something more concrete to say/point out here when I have this demo.

## Where do the mysterious checkboard patterns come from?

This is to me the most fascinating part about the JPEG. This is also the part where the lossy part happens. 

### Why represent images this way? 

### What information do we toss away?

## Chroma Sub-sampling 



