[meta title:"Unraveling The JPEG" description:"JPEG images are everywhere, yet how they work remains a mystery to most. The secret is getting rid of almost unnoticeable details to get the smallest filesize - but what does that look like? Let's see what our eyes can't see." /]

[Nav fullWidth:true /]

[Header
  title:`["Unraveling", "The JPEG"]`
  longTitle:`["Unraveling", "The JPEG"]`
  date:"April 15, 2019"
  dek:"JPEG images are everywhere, but how do they work? The secret is getting rid of almost unnoticeable details to get the smallest filesize — but what does that look like? Let's see what our eyes can't see!"
  fullWidth:true
  authors:`[{
    name: "Omar Shehata",
    role: ''
  }]`
  doi:""
  archive:""
  source:""
/]

It's easy to take it for granted that you can send a picture to a friend without worrying about what device, browser, or operating system they’re using, but things weren’t always this way. By the early 1980's, computers could store and display digital images, but there were many competing ideas about how best to do that, so you couldn't just send an image from one computer to another and expect it to work. To solve this problem, the Joint Photographic Experts Group (JPEG), a committee of experts from all over the world, was established in 1986 as a joint effort by the ISO and the IEC — two international standards organizations headquartered in Geneva, Switzerland.

JPEG, the group of people, created JPEG, a standard for digital image compression in 1992. Anyone who's ever used the internet has probably seen a JPEG-encoded image. It is by far the most ubiquitous way of encoding, sending and storing images. From web pages to email to social media, JPEGs are used billions of times a day — almost every time we view or send images online. Without JPEG, the web would be a little less colorful, a lot slower, and probably have far fewer cat pictures!

This article is about how to decode a JPEG image. Or in other words, it's about what it takes to convert the compressed data stored on your computer to the image that appears on the screen. It's worth learning about not just because it's important to understand the technology we all use everyday, but as we unravel the layers of compression, we learn a bit about perception and vision, and about what details our eyes are most sensitive to. 

It's also just a lot of fun to play with images this way.

[br/]

[FullWidth]
[img style:`{width: '100%'}` src:"static/images/glitchy-cat.gif"/]
[/FullWidth]

[br/]

## Peering Inside a JPEG

Everything on a computer is stored as a series of binary numbers. Typically, these bits, the zeroes and ones, are arranged in groups of eight, known as bytes. When you open a JPEG image on your computer, something (the browser, your operating system, or something else) has to decode the bytes to recover the original image as a list of colors that can then be displayed.

If you download [Reference content:"The adorable kitten image used in this article was taken by <a href='https://unsplash.com/photos/NodtnCsLdTE'>Mikhail Vasilyev on Unplash</a>"]that picture of the cat[/Reference] and open it using any text editor, you'll see a bunch of garbled characters.

[Right fullWidth:true]
  [img src:"static/images/blanket-cat-notepad.png"/]
  [caption]
    Here I'm using [Notepad++](https://notepad-plus-plus.org/) to edit the file, since common text editors like Windows' Notepad will change the file's binary contents when you save it so it's no longer a valid JPEG.
  [/caption]
[/Right]

[br/]

By opening an image in a text editor, you’ve confused the computer, in the same way you confuse your brain when you rub your eyes too hard and start to see blotches of dimness and color!

These blotches you see — known as [a href:"https://en.wikipedia.org/wiki/Phosphene"]“phosphenes”[/a] — don't come from any light stimulus, nor are they hallucinations made up in your mind. They arise because your brain assumes that any electrical signal arriving through the nerves in your eye is conveying light information. The brain needs to make this assumption because there’s no way to know whether a given signal is sound, sight, or something else. All the nerves in your body carry exactly the same type of electrical pulse. When you apply pressure by rubbing your eyes, you’re sending non-visual signals that trigger the receptors in your eye, which your brain interprets — incorrectly, in this case — as vision. You can literally see the pressure!

It’s fun to think about how similar computers are to our brains, but this is also a useful analogy because it illustrates how much the meaning of data — whether carried through a body by nerves, or stored in a computer — relies on how you interpret it. All binary data is made up of ones and zeroes, basic components that could be conveying any kind of information. Your computer often guesses how to interpret it using clues, like the file extension. Here we’ve forced it to interpret it as text, because that’s what a text editor expects.

To understand how a JPEG image is decoded we need to see the original signals themselves — the binary data. This can be done with a [Tooltip content:"You don't necessarily <i>need</i> a hex editor. You can edit the characters as text, save the file, and re-open it as an image just fine. But since our goal is to understand how JPEG stores images, it's helpful to be able to actually read the bytes!"]hex editor[/Tooltip]; or it can be done right here in this webpage! Below is the image next to [Tooltip content:"The only thing omitted here is the header, which is the first ~500 bytes that contain metadata like the width and height of the image. We'll revist this later in the article."]all of its bytes[/Tooltip], represented as decimal numbers. You can make changes to the bytes, and it will re-decode and display the new, edited image as you type.

[RawEditor ref:"Raw1" fullWidth:true imageUrl:"static/images/blanket-cat.jpg" showHeader:false /]

[br/]

[aside]
_Hint: try scrolling down and removing a few chunks. Don't worry, you can always reset the image back to the original!_[br/]
[/aside]

There's a lot you can learn just from playing around with this editor. For example, can you figure out the order the pixels are stored in?

Something strange in the example above is that changing some numbers doesn't seem to impact the image at all, while [EditorLink editor:`refs.Raw1` line:1 search:' 17 ' replace:' 0 ']setting the 17 on line 1 to 0[/EditorLink] completely ruins the image! Other actions, like [EditorLink editor:`refs.Raw1` line:1988 search:' 7 ' replace:' 254 ']setting the 7 on line 1988 to 254[/EditorLink] change the color, but only for subsequent pixels.

Perhaps what's most peculiar is that some numbers change not just the color but the shape of the image as well. Change the [EditorLink editor:`refs.Raw1` line:12 search:' 70 ' replace:' 2 ']70 in line 12 to 2[/EditorLink] and look at the top row of the image to see what I mean. You'll always find these mysterious checkboard patterns lurking regardless of what JPEG you're using.

It's hard to decipher how the image can be reconstructed from these bytes by playing around like this, because JPEG compression is actually composed of 3 different compression techniques, which are applied in successive layers. We'll look at each of these layers of compression separately to unravel this mysterious behavior we're seeing.


[inset]

### The three layers of JPEG compression
1. Chrominance Subsampling
2. Discrete Cosine Transform & Quantization
3. Huffman, Run-Length & Delta Encoding

[/inset]

To give you an idea of the scale of this compression, notice that the image above is represented using exactly 79,819 numbers, which makes it about 79 kilobytes. If it were stored with no compression, 3 numbers would be needed for each pixel — one for each of the red, green and blue components. That would mean a total of 917,700 numbers, or about 917 kilobytes. With JPEG compression, the resulting file is over **ten times smaller**!

In fact, this image can be squeezed into far fewer bytes. Below is the image next to a version of it that was compressed down to just 16 kilobytes, which makes it **fifty seven times smaller** than the uncompressed version would be!

[img src:"static/images/compression-comparison.png"/]
[br/]

If you look closely you'll see that these images are not identical. Both are JPEG-encoded images, but the one on the right is much smaller in terms of filesize. It also doesn't look as nice (notice how blocky the colors look in the background). The fact that the image changes and loses some detail when we compress it is what makes JPEG a **lossy compression** technique.

## Part 1 - Chrominance Subsampling

Here's the image with just the first layer of compression applied.

[ChromaEditor ref:"Chroma1" imageUrl:"static/images/blanket-cat-smallest.jpg" /]

[aside]
_Hint: Notice that removing one number ruins all the colors. But removing exactly 6, or any multiple of 6, has a minimal effect on the image._[br/]
[/aside]

It's a little more straightforward to decipher now. It's almost a simple list of colors, where each byte changes exactly one pixel, and yet it's already almost twice as small as the uncompressed image (which would be ~300 kb for this smaller size). Can you guess why?

You can tell that these numbers don't represent the standard red, green and blue components because [EditorLink editor:`refs.Chroma1` pattern:'zero-all']replacing all the numbers with 0[/EditorLink] turns the image green (as opposed to black). 

This is because these bytes represent the [EditorLink editor:`refs.Chroma1` pattern:'isolate-Y' scale:4]Y[/EditorLink] (brightness), [EditorLink editor:`refs.Chroma1` pattern:'isolate-Cb' scale:4]Cb[/EditorLink] (relative blueness), and [EditorLink editor:`refs.Chroma1` pattern:'isolate-Cr' scale:4]Cr[/EditorLink] (relative redness) of the image.

Why not just use RGB? After all, that's how most modern screens work. Your monitor can display any color by turning on red, green and blue lights at various intensities for each pixel. White is displayed by turning on all 3 colors at full brightness, while black is displayed by turning them all off.

[br/]
[img src:"static/images/BlackWhiteGray_Purdue.gif"/]
[caption]Credit: http://www.chem.purdue.edu/jmol/cchem/RGBColors/body_rgbcolors.html [/caption]
[br/]

That's also very similar to how human eyes work. The color receptors in our eyes known as “cones” are split into three types, each of which is mostly sensitive either to red, green, or blue. Rods, the other type of receptor we have in our eyes, can only detect changes in brightness, but they’re far more sensitive, and we have about one hundred and twenty million of them, compared to a measly six million cones.

This means that our eyes are much better at detecting changes in brightness than they are at detecting changes in color. If we can separate the color from the brightness, we can throw away a bit of the color without anyone noticing. This is exactly what chrominance subsampling is. In the example above, each pixel has one Y component, while each 4 pixels share one Cb and one Cr, so the image contains only a quarter as much color information as it originally did. 

[aside]
Using the YCbCr colorspace is not unique to JPEG. In fact, it was originally developed in 1938 (TODO MAKE THIS  ALINK https://en.wikipedia.org/wiki/GeorgesValensi ) for TV broadcasts. Not everyone had color TVs, so separating out the color from the luminance allowed everyone to receive the same transmission, and TVs that didn't support color would just use the luminance component.
[/aside]

This is why removing 1 number from the diagram above completely ruins the color. Here, the [Tooltip content:"In general, JPEG images need not store the components in any particular order. They might be interleaved like in this example, or all the Y components of the image could be stored followed by all the Cb etc. The header of the JPEG is what tells us how the components are stored."]components are stored[/Tooltip] as **Y Y Y Y Cb Cr**. Removing the first number causes the Cb value to be interpreted as Y, the Cr as Cb, and creates a ripple effect that flips all the colors across the image.

There's nothing in the JPEG specification that says you must use YCbCr, or that you can't subsample the Y component. Instead of taking it for granted that it's good to preserve as much of the Y as possible, you can see for yourself in the diagram below what it would look to subsample each component individually.

[var name:"subsamplePercent" value:0.15 /]
[SubsampleGrid imageUrl:"static/images/blanket-cat-tiny.jpg" subsamplePercent:`subsamplePercent` /]
[Range value:subsamplePercent min:0 max:1 step:0.05 /]

[aside]
Removing a bit of blue isn't as noticeable as removing red or green. This is because of the six million cones you have in your eyes, about 64% are most sensitive to red, 32% to green, and only 2% to blue.
[/aside]

Subsampling the Y component (bottom left) has the greatest effect on the image quality. Even a tiny bit is already noticable. You can move the slider to see how removing a greater % of each component affects the image. 

Representing an image in the YCbCr colorspace doesn't in itself make it any smaller than using RGB, but it allows us to more easily pick out less noticeable details to throw away (in this case, color). This idea of finding new ways to represent data to make it more compressible is very common in compression techniques, and is at the heart of what the next layer does.

## Part 2 - Discrete Cosine Transform & Quantization

This layer of compression is largely the defining feature of JPEG. After the colors are converted to YCbCr, the components are compressed individually, so we can focus on just the Y component for the rest of the article. Here's what the bytes for the Y component look like with this layer applied.

[DctEditor ref:"DCT1" comp:"Y" imageUrl:"static/images/blanket-cat-smallest.jpg" /]

[aside]
Hint: Try clicking on any pixel in the image to see the line in the editor that represents it. Try removing numbers from the end, or adding a few zero's to any individual number to make its effect more obvious.
[/aside]

At first glance, this seems like very poor compression. There are 100,000 pixels in this image, and yet it takes 102,400 numbers to represent the luminance of each pixel — that's worse than not compressing it at all!

But notice that most of these values are 0. In fact, [EditorLink editor:`refs.DCT1` pattern:"remove-zeros"]all of these zeros can be removed[/EditorLink] with no change to the image. This leaves only ~23,000 numbers, which makes it about 4x smaller!

In this layer lies the secret to the checkerboard patterns. Unlike the other effects we've seen, the appearance of these patterns is not a glitch. They are in fact the building blocks of the entire image! Every line in the editor above contains exactly 64 numbers, known as the Discrete Cosine Transform (DCT) coefficients, which correspond to intensities of 64 unique patterns.

You can see each of these patterns by zeroing out all but one of the numbers in any line. Here's an image that shows all 64 of them individually.

[data name:"DCT-grid" source:"DCT-grid.json" /]
[data name:"DCT-circle" source:"DCT-circle.json" /]
[data name:"DCT-eye" source:"DCT-eye.json" /]
[DctEditor  ref:"DCT2" imageUrl:"static/images/DCTGrid.jpg" override:DCT-grid/]

These patterns are special because they form a basis for 8x8 images. If you're not familiar with linear algebra, what that means is that any 8x8 image, anything at all that you can imagine, can be made out of these specific 64 patterns. The Discrete Cosine Transform is the process of converting the colors of an image to these 64 coefficients. Here's [EditorLink editor:`refs.DCT2` pattern:"animate-DCT" DCT:DCT-circle]how you would form a circle[/EditorLink] by combining these patterns, or [EditorLink editor:`refs.DCT2` pattern:"animate-DCT" DCT:DCT-eye]the cat's face[/EditorLink]. You can [EditorLink editor:`refs.DCT2` pattern:"animate-DCT" DCT:DCT-grid]click here to go back to the grid of 64 patterns[/EditorLink].

It seems like magic to say that any image can be represented using 64 specific patterns. But this is the same thing as saying any location on the Earth can be represented using only two numbers: longitude and latitude. The surface of the Earth is two-dimensional, so two numbers are needed. An 8 x 8 image is sixty-four-dimensional, so we need sixty-four numbers.

In terms of compression, it’s not obvious how this helps us. If we need sixty-four numbers to represent an 8 x 8 image, why is this better than storing the sixty-four luminance components? For the same reason we converted from the three numbers of RGB to the three numbers of YCbCr: it allows us to remove detail that’s less noticeable.

While JPEG only applies the Discrete Cosine Transform to blocks of 8 x 8 pixels at a time, there’s no reason we can’t apply it to the whole image. Here’s what it looks like applied to the Y component of the entire image:

[FullDctEditor ref:"DCT3" imageUrl:"static/images/blanket-cat-smallest.jpg"/]

We can [EditorLink editor:`refs.DCT3` pattern:"remove-{170}"]remove over 60,000 numbers[/EditorLink] from the end with almost no noticeable change. But notice that if [EditorLink editor:`refs.DCT3` pattern:"zero-{5}"]we set just the first five numbers to zero[/EditorLink] (ignoring the first because it just makes the image darker) there's already an obvious difference.

The numbers at the beginning represent the lower frequency changes in the image, which our eyes are more sensitive to, while numbers towards the end represent the higher frequency changes, which we're less sensitive to, so we don't notice when they're gone. I promised I'd show you "what our eyes can't see", so let's isolate these high frequency details by setting the [EditorLink editor:`refs.DCT3` pattern:"zero-{5000}"]first 5000 numbers to zero[/EditorLink].

What you're looking at here is all the areas of the image that have the greatest change from one pixel to the next. The cat's eyes, whiskers, fuzzy blanket and shadows on the bottom left all stand out. This can be taken even further, to setting the first [EditorLink editor:`refs.DCT3` pattern:"zero-{10000}"]10,000 numbers to zero[/EditorLink], [EditorLink editor:`refs.DCT3` pattern:"zero-{20000}"]20,000[/EditorLink], [EditorLink editor:`refs.DCT3` pattern:"zero-{40000}"]40,000[/EditorLink] or [EditorLink editor:`refs.DCT3` pattern:"zero-{60000}"]60,000[/EditorLink].

These details are what JPEG removes during this compression step. Converting the colors to the DCT coefficients is not a lossy operation. It's the quantization step that's lossy, where values that are either high frequency, or are close to zero, are removed. The more you remove, the greater the compression, and worse the final quality of the image is. This is why the version of the image in the first section that was 57x smaller looked blocky. Each 8 x 8 block was represented by far fewer DCT coefficients.

[aside]
One really cool thing you can do with this technique is progressively stream images. Imagine seeing a blurry version of the whole image, and slowly seeing it become more and more detailed as the download progresses and more DCT coefficients are available. This is actually possible to do with JPEG, but not as commonly used.
[/aside]

Just for fun, here's what it looks like using just [EditorLink editor:`refs.DCT3` pattern:"remove-{268}"]24,000 numbers[/EditorLink], or just [EditorLink editor:`refs.DCT3` pattern:"remove-{316}"]5000 numbers[/EditorLink]. Pretty blurry, but almost recognizable!

## Part 3 - Huffman, Run-Length & Delta Encoding

All the compression steps so far have been lossy. This last layer, by contrast, is lossless. It doesn't remove any information, but it does make the filesize significantly smaller.

How do you compress something without throwing away any information? Think about how you would represent a simple solid black image. 

[RawEditor ref:"Huffman1" fullWidth:true imageUrl:"static/images/black.jpg" showHeader:false /]

JPEG uses ~5,000 numbers to represent this. But we can do much better. Can you think of an encoding scheme to represent this image using as few bytes as possible?

The smallest I could think of was 4 bytes: 3 to specify the color and 1 to specify how many pixels have this color. The idea of expressing all repeated values concisely this way is called **run-length encoding**. It's lossless because we can recover the encoded data exactly as it was before. 

The filesize is much bigger than that with JPEG because remember that in the second layer, the compression is applied to 8 x 8 blocks at a time. So at minimum we'll need 1 DCT coefficient for each 64 pixel block. With run-length encoding, instead of storing 1 DCT coefficient followed by 63 zero's for this image, we can just store one number and say "the rest are zero".

**Delta-encoding** is the reason some numbers change the color for all subsequent pixels. The idea is instead of storing the absolute value of each byte, you can store its value relative to the byte before it. For example, instead of storing:

```
12 13 14 16 17 18 19 20
```

You would start with 12, and from there, just store how much you need to add or subtract to get the next number. So that would be:

```
12 1 1 2 1 1 1 1
```

This by itself doesn't reduce the number of bytes you have, but you can imagine it can help a lot if you're doing it before applying something like run-length encoding. The first DCT coefficient in each block is delta-encoded. This is because JPEG assumes that the average color (the first DCT coefficient) between blocks won't change too much, even if the details (the 63 other DCT coefficients) do change.

This all leaves just one final mystery: how can changing just a single number completely wreck the image? This was not a property of any of the other compression layers. The answer lies in the JPEG header. It's the first ~500 bytes that contain metadata about the image, like its width and height, and has been omitted from all the figures so far.

Below is the original image with the header included.

[RawEditor ref:"Huffman2" fullWidth:true imageUrl:"static/images/blanket-cat.jpg" /]

Without the header, it's practically impossible (or at least very difficult) to decode the JPEG image. It would be as if I was trying to describe a painting to you, in a language I just made up on the spot, just to describe this one particular painting, and expected you to understand. It's probably going to be a very elegant and concise description, but it would be meaningless to anyone other than me. 

This may sound ridiculous, but this is exactly what's going on here. Every single JPEG image is encoded with a language-of-sorts that's unique to this particular image. The dictionary you need is stored in the header. This technique is called **Huffman encoding**, and the dictionary is called a Huffman table. This table is marked in the header by two bytes: 255 followed by 196. Each component may have its own Huffman table.

Changes to these Huffman tables will have the most dramatic effects on any image. Changing [EditorLink editor:`refs.Huffman2` line:15 search:'125 1' replace:'125 12']the second 1 to 12 on line 15[/EditorLink] is a good example. Changing anything after the 125 on that line works too. 

The Huffman tables have such a dramatic effect on the image because they tell us how to read the individual _bits_. So far we've just been dealing with the binary numbers in decimal. This hides the fact that if you want to store *1* in a byte, it would look like *00000001*, because each byte must have exactly 8 bits, even if it's only using 1.

This is potentially a huge waste of storage if you have a lot of small numbers. Huffman encoding is a technique that allows us to relax this requirement that each number must occupy 8 bits. That means if you see the two bytes:

```
234 115
```

Based on the Huffman table, these could actually be 3 values. To extract them, you'll need to first break them into their individual bits:

```
11101010 01110011
``` 

Then follow the table to figure out how to group them. For example, it could be the first 6 bits (111010) which is 58 in decimal, followed by another 5 bits (10011) which is 19 and finally the last 4 bits (0011), which is 3. 

This is why it's very difficult to make sense of the bytes at this layer of compression. The bytes don't actually represent what they seem to represent. The exact process behind how to follow a Huffman table to extract the values from these bytes is beyond the scope of this article, but since it's not unique to JPEG, [Reference content:"Tom Scott's video on Huffman Encoding https://www.youtube.com/watch?v=JsTptu56GM8, also you'll need the ImpulseAdventure article"]there are many good explanations of it[/Reference].

[aside]
One neat trick you can do with this knowledge is to strip out the header from a JPEG image and save it separately. You're effectively making it so only you can read it. Facebook https://code.fb.com/android/the-technology-behind-preview-photos/ actually does this to make JPEG images even smaller. 

Another thing you can do is change the Huffman table just slightly. To anyone else, it looks like a corrupted image. But only you would know the magic edit needed to fix it.
[/aside]

[hr/]

So to summarize, what all does it take to decode a JPEG image? You need to:

1. Extract the Huffman table(s) from the header.
2. Extract the Discrete Cosine Transform coefficients of each component, for each 8 x 8 block, by undoing the Huffman encoding, and the run-length & delta encoding.
3. Combine the cosine waves based on the coefficients to get back the pixel values for each 8 x 8 block (this is known as the inverse Discrete Cosine Transform).
4. Scale up the chrominance components if they were subsampled (the header has this information).
5. Convert the resulting YCbCr of each pixel to RGB.
6. Display the image!

I hope this makes you appreciate all the work that goes into it viewing even a simple cat picture! 

All the code for this article is open source and public domain. You can find it at X. 

[AuthorBio]
**Omar Shehata** is a graphics programmer at Cesium and an Egyptian citizen in Philadelphia, PA.

Edited by Matthew Conlen and Victoria Uren.
[/AuthorBio]

[NextArticle fullWidth:true /]